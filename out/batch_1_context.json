{
  "batch": {
    "batch_id": 1,
    "files": [
      "PULL_REQUEST.md",
      "QUICKSTART.md",
      "README.md",
      "STARTUP_GUIDE.md",
      "app/__init__.py",
      "app/blueprints/api/market_routes.py",
      "app/config.py",
      "app/integrations/free_gold_api_client.py",
      "app/integrations/polygon_client.py",
      "app/integrations/twelvedata_client.py",
      "app/services/gold_service.py",
      "app/services/market_prediction_service.py",
      "app/static/css/dashboard.css",
      "app/static/js/etf_forecast.js",
      "app/templates/about.html",
      "app/templates/dashboard.html"
    ],
    "loc": 1368,
    "notes": "Single batch (LOC within limit)."
  },
  "pr": {
    "id": 2,
    "title": "Switch metals and ETF data to Twelve Data",
    "description": null
  },
  "files": [
    {
      "path": "app/__init__.py",
      "added": 2,
      "removed": 0,
      "loc": 2,
      "patch": "@@ -109,10 +109,12 @@ def register_blueprints(app):\n     from app.blueprints.api.gold_routes import gold_api_bp\n     from app.blueprints.api.astrology_routes import astrology_api_bp\n     from app.blueprints.api.prediction_routes import prediction_bp\n+    from app.blueprints.api.market_routes import market_api_bp\n \n     app.register_blueprint(gold_api_bp, url_prefix='/api/gold')\n     app.register_blueprint(astrology_api_bp, url_prefix='/api/astrology')\n     app.register_blueprint(prediction_bp, url_prefix='/api/predictions')\n+    app.register_blueprint(market_api_bp, url_prefix='/api/market')\n \n \n def register_error_handlers(app):",
      "status": "modified"
    },
    {
      "path": "app/blueprints/api/market_routes.py",
      "added": 72,
      "removed": 0,
      "loc": 72,
      "patch": "@@ -0,0 +1,72 @@\n+\"\"\"\n+Market prediction API routes for ETF forecasts using Twelve Data.\n+\"\"\"\n+import logging\n+from flask import Blueprint, jsonify, request\n+from app import limiter\n+from app.services.market_prediction_service import get_market_prediction_service\n+from app.utils.validators import validate_days_parameter\n+\n+logger = logging.getLogger(__name__)\n+\n+market_api_bp = Blueprint('market_api', __name__)\n+\n+\n+@market_api_bp.route('/predictions', methods=['GET'])\n+@limiter.limit(\"15 per minute\")\n+def get_market_predictions():\n+    \"\"\"\n+    Get ETF price predictions based on recent trends.\n+\n+    Query Parameters:\n+        tickers (str): Comma-separated list of tickers (default: SLV,GLD)\n+        days (int): Prediction horizon (1-10, default: 5)\n+        window (int): Historical window in trading days (10-90, default: 30)\n+    \"\"\"\n+    try:\n+        tickers_raw = request.args.get('tickers', 'SLV,GLD')\n+        tickers = [t.strip().upper() for t in tickers_raw.split(',') if t.strip()]\n+\n+        days = request.args.get('days', 5, type=int)\n+        window_days = request.args.get('window', 30, type=int)\n+\n+        if not tickers:\n+            return jsonify({\n+                'success': False,\n+                'error': 'Tickers parameter is required'\n+            }), 400\n+\n+        if not validate_days_parameter(days, min_days=1, max_days=10):\n+            return jsonify({\n+                'success': False,\n+                'error': 'Days parameter must be between 1 and 10'\n+            }), 400\n+\n+        if not validate_days_parameter(window_days, min_days=10, max_days=90):\n+            return jsonify({\n+                'success': False,\n+                'error': 'Window parameter must be between 10 and 90'\n+            }), 400\n+\n+        logger.info(\"Fetching %s-day market predictions for %s\", days, tickers)\n+\n+        service = get_market_prediction_service()\n+        result = service.get_predictions(tickers=tickers, days=days, window_days=window_days)\n+\n+        if not result:\n+            return jsonify({\n+                'success': False,\n+                'error': 'Unable to generate market predictions. Check API key and try again.'\n+            }), 503\n+\n+        if result.get('success') is False:\n+            return jsonify(result), 503\n+\n+        return jsonify(result), 200\n+\n+    except Exception as e:\n+        logger.error(\"Error in get_market_predictions: %s\", str(e))\n+        return jsonify({\n+            'success': False,\n+            'error': 'Internal server error'\n+        }), 500",
      "status": "added"
    },
    {
      "path": "app/config.py",
      "added": 13,
      "removed": 0,
      "loc": 13,
      "patch": "@@ -18,6 +18,8 @@ class Config:\n \n     # API Keys - Never expose in client code\n     METALS_API_KEY = os.getenv('METALS_API_KEY', '')\n+    POLYGON_API_KEY = os.getenv('POLYGON_API_KEY', '')\n+    TWELVEDATA_API_KEY = os.getenv('TWELVEDATA_API_KEY', '')\n \n     # Security Headers (Flask-Talisman)\n     TALISMAN_FORCE_HTTPS = False  # Set True in production with proper SSL\n@@ -62,6 +64,16 @@ class Config:\n     GOLD_CURRENCY = \"USD\"\n     GOLD_TRAJECTORY_DAYS = 30\n \n+    # Polygon.io API\n+    POLYGON_API_BASE_URL = \"https://api.polygon.io\"\n+\n+    # Market prediction cache\n+    CACHE_TIMEOUT_MARKET_PREDICTIONS = 300\n+\n+    # Twelve Data API\n+    TWELVEDATA_API_BASE_URL = \"https://api.twelvedata.com\"\n+    TWELVEDATA_GOLD_SYMBOL = \"XAU/USD\"\n+\n     # Astrology Settings\n     ASTROLOGY_DEFAULT_LOCATION = {\n         'name': 'New Delhi',\n@@ -142,6 +154,7 @@ class TestingConfig(Config):\n \n     # Test-specific settings\n     METALS_API_KEY = 'test-api-key'\n+    TWELVEDATA_API_KEY = 'test-api-key'\n \n \n # Configuration dictionary",
      "status": "modified"
    },
    {
      "path": "app/integrations/free_gold_api_client.py",
      "added": 1,
      "removed": 1,
      "loc": 2,
      "patch": "@@ -104,7 +104,7 @@ def get_mock_data(currency: str = 'USD') -> Dict:\n             'change': 12.50,\n             'change_percent': 0.61,\n             'source': 'mock_data',\n-            'note': 'This is mock data for development. Configure METALS_API_KEY for real data.'\n+            'note': 'This is mock data for development. Configure TWELVEDATA_API_KEY for real data.'\n         }\n \n     @staticmethod",
      "status": "modified"
    },
    {
      "path": "app/integrations/polygon_client.py",
      "added": 103,
      "removed": 0,
      "loc": 103,
      "patch": "@@ -0,0 +1,103 @@\n+\"\"\"\n+Polygon.io API client for market data.\n+\"\"\"\n+from typing import Dict, Optional\n+from datetime import datetime\n+import logging\n+import requests\n+from flask import current_app\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PolygonClient:\n+    \"\"\"Client for Polygon.io market data.\"\"\"\n+\n+    def __init__(self, api_key: Optional[str] = None, base_url: Optional[str] = None):\n+        self.api_key = api_key or current_app.config.get('POLYGON_API_KEY', '')\n+        self.base_url = base_url or current_app.config.get('POLYGON_API_BASE_URL', 'https://api.polygon.io')\n+        self.session = requests.Session()\n+        self.session.headers.update({\n+            'Accept': 'application/json'\n+        })\n+\n+    def get_aggregates(\n+        self,\n+        ticker: str,\n+        start_date: str,\n+        end_date: str,\n+        multiplier: int = 1,\n+        timespan: str = 'day',\n+        adjusted: bool = True,\n+        sort: str = 'asc',\n+        limit: int = 50000\n+    ) -> Optional[Dict]:\n+        \"\"\"\n+        Get aggregated bars for a ticker.\n+\n+        Args:\n+            ticker: Ticker symbol (e.g., SLV)\n+            start_date: YYYY-MM-DD\n+            end_date: YYYY-MM-DD\n+            multiplier: Size of the timespan multiplier\n+            timespan: Size of the time window\n+            adjusted: Whether results are adjusted\n+            sort: asc or desc\n+            limit: Max results\n+        \"\"\"\n+        if not self.api_key:\n+            logger.error(\"Polygon API key is not configured\")\n+            return {\n+                'status': 'ERROR',\n+                'error': 'POLYGON_API_KEY not configured'\n+            }\n+\n+        try:\n+            endpoint = (\n+                f\"{self.base_url}/v2/aggs/ticker/{ticker}/range/\"\n+                f\"{multiplier}/{timespan}/{start_date}/{end_date}\"\n+            )\n+            params = {\n+                'adjusted': 'true' if adjusted else 'false',\n+                'sort': sort,\n+                'limit': limit,\n+                'apiKey': self.api_key\n+            }\n+\n+            response = self.session.get(endpoint, params=params, timeout=15)\n+            response.raise_for_status()\n+\n+            data = response.json()\n+            if data.get('status') == 'OK':\n+                return data\n+\n+            error_message = data.get('error', data.get('message', 'Unknown error'))\n+            logger.error(\"Polygon API error for %s: %s\", ticker, error_message)\n+            return {\n+                'status': data.get('status', 'ERROR'),\n+                'error': error_message\n+            }\n+\n+        except requests.exceptions.Timeout:\n+            logger.error(\"Polygon API request timeout for %s\", ticker)\n+            return {\n+                'status': 'ERROR',\n+                'error': 'Polygon API request timeout'\n+            }\n+        except requests.exceptions.RequestException as e:\n+            logger.error(\"Polygon API request error for %s: %s\", ticker, str(e))\n+            return {\n+                'status': 'ERROR',\n+                'error': f'Polygon API request error: {str(e)}'\n+            }\n+        except Exception as e:\n+            logger.error(\"Unexpected error in Polygon client for %s: %s\", ticker, str(e))\n+            return {\n+                'status': 'ERROR',\n+                'error': f'Unexpected Polygon client error: {str(e)}'\n+            }\n+\n+    @staticmethod\n+    def ms_to_date(ms: int) -> str:\n+        \"\"\"Convert millisecond timestamp to YYYY-MM-DD string (UTC).\"\"\"\n+        return datetime.utcfromtimestamp(ms / 1000).strftime('%Y-%m-%d')",
      "status": "added"
    },
    {
      "path": "app/integrations/twelvedata_client.py",
      "added": 89,
      "removed": 0,
      "loc": 89,
      "patch": "@@ -0,0 +1,89 @@\n+\"\"\"\n+Twelve Data API client for market and metals data.\n+\"\"\"\n+from typing import Dict, Optional\n+from datetime import datetime\n+import logging\n+import requests\n+from flask import current_app\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class TwelveDataClient:\n+    \"\"\"Client for Twelve Data API.\"\"\"\n+\n+    def __init__(self, api_key: Optional[str] = None, base_url: Optional[str] = None):\n+        self.api_key = api_key or current_app.config.get('TWELVEDATA_API_KEY', '')\n+        self.base_url = base_url or current_app.config.get('TWELVEDATA_API_BASE_URL', 'https://api.twelvedata.com')\n+        self.session = requests.Session()\n+        self.session.headers.update({\n+            'Accept': 'application/json'\n+        })\n+\n+    def get_time_series(\n+        self,\n+        symbol: str,\n+        interval: str = '1day',\n+        outputsize: int = 30,\n+        start_date: Optional[str] = None,\n+        end_date: Optional[str] = None\n+    ) -> Optional[Dict]:\n+        if not self.api_key:\n+            logger.error(\"Twelve Data API key is not configured\")\n+            return {\n+                'status': 'error',\n+                'message': 'TWELVEDATA_API_KEY not configured'\n+            }\n+\n+        try:\n+            endpoint = f\"{self.base_url}/time_series\"\n+            params = {\n+                'symbol': symbol,\n+                'interval': interval,\n+                'outputsize': outputsize,\n+                'apikey': self.api_key\n+            }\n+            if start_date:\n+                params['start_date'] = start_date\n+            if end_date:\n+                params['end_date'] = end_date\n+\n+            response = self.session.get(endpoint, params=params, timeout=15)\n+            response.raise_for_status()\n+            data = response.json()\n+\n+            if data.get('status') == 'error':\n+                logger.error(\"Twelve Data error for %s: %s\", symbol, data.get('message', 'Unknown error'))\n+                return data\n+\n+            return data\n+\n+        except requests.exceptions.Timeout:\n+            logger.error(\"Twelve Data request timeout for %s\", symbol)\n+            return {\n+                'status': 'error',\n+                'message': 'Twelve Data request timeout'\n+            }\n+        except requests.exceptions.RequestException as e:\n+            logger.error(\"Twelve Data request error for %s: %s\", symbol, str(e))\n+            return {\n+                'status': 'error',\n+                'message': f'Twelve Data request error: {str(e)}'\n+            }\n+        except Exception as e:\n+            logger.error(\"Unexpected error in Twelve Data client for %s: %s\", symbol, str(e))\n+            return {\n+                'status': 'error',\n+                'message': f'Unexpected Twelve Data client error: {str(e)}'\n+            }\n+\n+    @staticmethod\n+    def parse_datetime(value: str) -> Optional[datetime]:\n+        \"\"\"Parse Twelve Data datetime/date strings.\"\"\"\n+        for fmt in ('%Y-%m-%d %H:%M:%S', '%Y-%m-%d'):\n+            try:\n+                return datetime.strptime(value, fmt)\n+            except ValueError:\n+                continue\n+        return None",
      "status": "added"
    },
    {
      "path": "app/services/gold_service.py",
      "added": 136,
      "removed": 70,
      "loc": 206,
      "patch": "@@ -7,8 +7,8 @@\n import logging\n from flask import current_app\n \n-from app.integrations.metals_api_client import MetalsAPIClient\n from app.integrations.free_gold_api_client import FreeGoldAPIClient\n+from app.integrations.twelvedata_client import TwelveDataClient\n from app.services.cache_service import (\n     CacheService,\n     cache_gold_price,\n@@ -24,14 +24,14 @@ class GoldService:\n \n     def __init__(self):\n         \"\"\"Initialize gold service with API clients.\"\"\"\n-        self.metals_client = None\n+        self.twelvedata_client = None\n         self.free_gold_client = None\n \n-    def _get_metals_client(self) -> MetalsAPIClient:\n-        \"\"\"Get or create Metals API client.\"\"\"\n-        if self.metals_client is None:\n-            self.metals_client = MetalsAPIClient()\n-        return self.metals_client\n+    def _get_twelvedata_client(self) -> TwelveDataClient:\n+        \"\"\"Get or create Twelve Data client.\"\"\"\n+        if self.twelvedata_client is None:\n+            self.twelvedata_client = TwelveDataClient()\n+        return self.twelvedata_client\n \n     def _get_free_gold_client(self) -> FreeGoldAPIClient:\n         \"\"\"Get or create FreeGoldAPI client.\"\"\"\n@@ -73,25 +73,28 @@ def get_current_price(self, currency: str = 'USD', use_cache: bool = True) -> Op\n                 logger.debug(f\"Cache hit for gold price: {cache_key}\")\n                 return cached_data\n \n-        # Try primary source: Metals API\n-        if current_app.config.get('METALS_API_KEY'):\n-            logger.info(\"Fetching gold price from Metals API\")\n-            metals_client = self._get_metals_client()\n-            rate_data = metals_client.get_latest_rates(currency=currency)\n+        # Try primary source: Twelve Data\n+        if current_app.config.get('TWELVEDATA_API_KEY'):\n+            logger.info(\"Fetching gold price from Twelve Data\")\n+            twelvedata_client = self._get_twelvedata_client()\n+            symbol = current_app.config.get('TWELVEDATA_GOLD_SYMBOL') or f\"XAU/{currency}\"\n+            series_data = twelvedata_client.get_time_series(\n+                symbol=symbol,\n+                interval='1day',\n+                outputsize=2\n+            )\n \n-            if rate_data:\n-                formatted_data = MetalsAPIClient.format_gold_price(rate_data)\n-                if formatted_data:\n-                    # Cache the result\n-                    if use_cache:\n-                        timeout = current_app.config.get('CACHE_TIMEOUT_GOLD_CURRENT', 120)\n-                        CacheService.set(cache_gold_price(currency), formatted_data, timeout)\n+            formatted_data = self._format_twelvedata_current(series_data, currency)\n+            if formatted_data:\n+                if use_cache:\n+                    timeout = current_app.config.get('CACHE_TIMEOUT_GOLD_CURRENT', 120)\n+                    CacheService.set(cache_gold_price(currency), formatted_data, timeout)\n \n-                    logger.info(f\"Successfully fetched gold price from Metals API: ${formatted_data['price']}\")\n-                    return formatted_data\n+                logger.info(\"Successfully fetched gold price from Twelve Data: $%s\", formatted_data['price'])\n+                return formatted_data\n \n         # Fallback to FreeGoldAPI\n-        logger.warning(\"Metals API unavailable, trying FreeGoldAPI\")\n+        logger.warning(\"Twelve Data unavailable, trying FreeGoldAPI\")\n         free_gold_client = self._get_free_gold_client()\n         rate_data = free_gold_client.get_latest_rate(currency=currency)\n \n@@ -147,25 +150,24 @@ def get_price_trajectory(self, days: int = 30, currency: str = 'USD') -> Optiona\n         end_date = datetime.utcnow().date()\n         start_date = end_date - timedelta(days=days)\n \n-        # Try Metals API\n-        if current_app.config.get('METALS_API_KEY'):\n-            logger.info(f\"Fetching {days}-day gold trajectory from Metals API\")\n-            metals_client = self._get_metals_client()\n-            timeseries_data = metals_client.get_timeseries(\n-                start_date=start_date.strftime('%Y-%m-%d'),\n-                end_date=end_date.strftime('%Y-%m-%d'),\n-                currency=currency\n+        # Try Twelve Data\n+        if current_app.config.get('TWELVEDATA_API_KEY'):\n+            logger.info(\"Fetching %s-day gold trajectory from Twelve Data\", days)\n+            twelvedata_client = self._get_twelvedata_client()\n+            symbol = current_app.config.get('TWELVEDATA_GOLD_SYMBOL') or f\"XAU/{currency}\"\n+            series_data = twelvedata_client.get_time_series(\n+                symbol=symbol,\n+                interval='1day',\n+                outputsize=days\n             )\n \n-            if timeseries_data and timeseries_data.get('success'):\n-                trajectory = self._format_trajectory(timeseries_data, days)\n-                if trajectory:\n-                    # Cache the result\n-                    timeout = current_app.config.get('CACHE_TIMEOUT_GOLD_CURRENT', 120)\n-                    CacheService.set(cache_key, trajectory, timeout)\n+            trajectory = self._format_twelvedata_trajectory(series_data, currency)\n+            if trajectory:\n+                timeout = current_app.config.get('CACHE_TIMEOUT_GOLD_CURRENT', 120)\n+                CacheService.set(cache_key, trajectory, timeout)\n \n-                    logger.info(f\"Successfully fetched {len(trajectory['dates'])} days of gold prices\")\n-                    return trajectory\n+                logger.info(\"Successfully fetched %s days of gold prices\", len(trajectory['dates']))\n+                return trajectory\n \n         # Fallback: Generate mock trajectory (development only)\n         if current_app.config.get('DEBUG'):\n@@ -175,37 +177,74 @@ def get_price_trajectory(self, days: int = 30, currency: str = 'USD') -> Optiona\n         logger.error(\"Failed to fetch gold price trajectory\")\n         return None\n \n-    def _format_trajectory(self, timeseries_data: Dict, days: int) -> Optional[Dict]:\n-        \"\"\"\n-        Format timeseries data into trajectory structure.\n+    def _format_twelvedata_current(self, series_data: Dict, currency: str) -> Optional[Dict]:\n+        \"\"\"Format Twelve Data time series into current price structure.\"\"\"\n+        try:\n+            if not series_data or series_data.get('status') == 'error':\n+                return None\n \n-        Args:\n-            timeseries_data: Raw timeseries data from API\n-            days: Number of days requested\n+            values = series_data.get('values', [])\n+            if not values:\n+                return None\n \n-        Returns:\n-            Formatted trajectory data\n-        \"\"\"\n+            # Twelve Data returns latest first\n+            latest = values[0]\n+            previous = values[1] if len(values) > 1 else None\n+\n+            latest_price = float(latest.get('close'))\n+            previous_price = float(previous.get('close')) if previous else None\n+\n+            change = latest_price - previous_price if previous_price else 0.0\n+            change_percent = (change / previous_price * 100) if previous_price else 0.0\n+\n+            parsed_dt = TwelveDataClient.parse_datetime(latest.get('datetime', ''))\n+            timestamp = int(parsed_dt.timestamp()) if parsed_dt else int(datetime.utcnow().timestamp())\n+            date_str = parsed_dt.strftime('%Y-%m-%d') if parsed_dt else datetime.utcnow().strftime('%Y-%m-%d')\n+\n+            return {\n+                'price': round(latest_price, 2),\n+                'currency': currency,\n+                'timestamp': timestamp,\n+                'date': date_str,\n+                'change': round(change, 2),\n+                'change_percent': round(change_percent, 2),\n+                'source': 'twelvedata'\n+            }\n+        except Exception as e:\n+            logger.error(\"Error formatting Twelve Data current price: %s\", str(e))\n+            return None\n+\n+    def _format_twelvedata_trajectory(self, series_data: Dict, currency: str) -> Optional[Dict]:\n+        \"\"\"Format Twelve Data time series into trajectory structure.\"\"\"\n         try:\n-            rates = timeseries_data.get('rates', {})\n-            if not rates:\n+            if not series_data or series_data.get('status') == 'error':\n                 return None\n \n-            # Sort dates and extract prices\n-            sorted_dates = sorted(rates.keys())\n-            dates = sorted_dates[-days:] if len(sorted_dates) > days else sorted_dates\n-            prices = [rates[date].get('XAU', 0) for date in dates]\n+            values = series_data.get('values', [])\n+            if not values:\n+                return None\n+\n+            # Values are latest first; reverse to chronological\n+            values = list(reversed(values))\n+            dates = []\n+            prices = []\n+            for entry in values:\n+                dt_value = entry.get('datetime')\n+                close_value = entry.get('close')\n+                if not dt_value or close_value is None:\n+                    continue\n+                dates.append(dt_value.split(' ')[0])\n+                prices.append(round(float(close_value), 2))\n \n             return {\n                 'dates': dates,\n-                'prices': [round(p, 2) for p in prices],\n-                'currency': timeseries_data.get('base', 'USD'),\n+                'prices': prices,\n+                'currency': currency,\n                 'days': len(dates),\n-                'source': 'metals_api'\n+                'source': 'twelvedata'\n             }\n-\n         except Exception as e:\n-            logger.error(f\"Error formatting trajectory data: {str(e)}\")\n+            logger.error(\"Error formatting Twelve Data trajectory: %s\", str(e))\n             return None\n \n     def _generate_mock_trajectory(self, days: int, currency: str) -> Dict:\n@@ -299,22 +338,49 @@ def get_historical_price(self, date: str, currency: str = 'USD') -> Optional[Dic\n         if cached_data:\n             return cached_data\n \n-        # Try Metals API\n-        if current_app.config.get('METALS_API_KEY'):\n-            metals_client = self._get_metals_client()\n-            rate_data = metals_client.get_historical_rate(date=date, currency=currency)\n-\n-            if rate_data:\n-                formatted_data = MetalsAPIClient.format_gold_price(rate_data)\n-                if formatted_data:\n-                    # Cache with long timeout (historical data doesn't change)\n-                    timeout = current_app.config.get('CACHE_TIMEOUT_GOLD_HISTORICAL', 86400)\n-                    CacheService.set(cache_key, formatted_data, timeout)\n+        # Try Twelve Data\n+        if current_app.config.get('TWELVEDATA_API_KEY'):\n+            twelvedata_client = self._get_twelvedata_client()\n+            symbol = current_app.config.get('TWELVEDATA_GOLD_SYMBOL') or f\"XAU/{currency}\"\n+            series_data = twelvedata_client.get_time_series(\n+                symbol=symbol,\n+                interval='1day',\n+                outputsize=1,\n+                start_date=date,\n+                end_date=date\n+            )\n \n-                    return formatted_data\n+            formatted_data = self._format_twelvedata_historical(series_data, currency, date)\n+            if formatted_data:\n+                timeout = current_app.config.get('CACHE_TIMEOUT_GOLD_HISTORICAL', 86400)\n+                CacheService.set(cache_key, formatted_data, timeout)\n+                return formatted_data\n \n         return None\n \n+    def _format_twelvedata_historical(self, series_data: Dict, currency: str, date: str) -> Optional[Dict]:\n+        \"\"\"Format Twelve Data response into historical price structure.\"\"\"\n+        try:\n+            if not series_data or series_data.get('status') == 'error':\n+                return None\n+\n+            values = series_data.get('values', [])\n+            if not values:\n+                return None\n+\n+            entry = values[0]\n+            price = float(entry.get('close'))\n+\n+            return {\n+                'price': round(price, 2),\n+                'currency': currency,\n+                'date': date,\n+                'source': 'twelvedata'\n+            }\n+        except Exception as e:\n+            logger.error(\"Error formatting Twelve Data historical price: %s\", str(e))\n+            return None\n+\n \n # Singleton instance\n _gold_service = None",
      "status": "modified"
    },
    {
      "path": "app/services/market_prediction_service.py",
      "added": 213,
      "removed": 0,
      "loc": 213,
      "patch": "@@ -0,0 +1,213 @@\n+\"\"\"\n+Market prediction service using Twelve Data historical data.\n+Generates simple 5-day forecasts for ETFs.\n+\"\"\"\n+from datetime import datetime, timedelta\n+from typing import Dict, List, Optional, Tuple\n+import logging\n+\n+from flask import current_app\n+\n+from app.integrations.twelvedata_client import TwelveDataClient\n+from app.services.cache_service import CacheService\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MarketPredictionService:\n+    \"\"\"Service for market price forecasts based on recent trends.\"\"\"\n+\n+    def __init__(self):\n+        self.twelvedata_client = None\n+\n+    def _get_twelvedata_client(self) -> TwelveDataClient:\n+        if self.twelvedata_client is None:\n+            self.twelvedata_client = TwelveDataClient()\n+        return self.twelvedata_client\n+\n+    def get_predictions(\n+        self,\n+        tickers: List[str],\n+        days: int = 5,\n+        window_days: int = 30\n+    ) -> Optional[Dict]:\n+        \"\"\"\n+        Generate simple forecasts for a list of tickers.\n+\n+        Args:\n+            tickers: List of ticker symbols\n+            days: Prediction horizon (1-10)\n+            window_days: Historical window (trading days)\n+        \"\"\"\n+        if not tickers:\n+            return {\n+                'success': False,\n+                'error': 'Tickers list is required'\n+            }\n+\n+        days = max(1, min(days, 10))\n+        window_days = max(10, min(window_days, 90))\n+\n+        cache_key = self._cache_key(tickers, days, window_days)\n+        cached = CacheService.get(cache_key)\n+        if cached:\n+            return cached\n+\n+        if not current_app.config.get('TWELVEDATA_API_KEY'):\n+            logger.error(\"Twelve Data API key not configured\")\n+            return {\n+                'success': False,\n+                'error': 'TWELVEDATA_API_KEY not configured'\n+            }\n+\n+        end_date = datetime.utcnow().date()\n+        start_date = end_date - timedelta(days=window_days * 3)\n+\n+        results: Dict[str, Dict] = {}\n+        errors: List[str] = []\n+        for ticker in tickers:\n+            ticker_data, error = self._predict_for_ticker(\n+                ticker=ticker,\n+                start_date=start_date.strftime('%Y-%m-%d'),\n+                end_date=end_date.strftime('%Y-%m-%d'),\n+                days=days,\n+                window_days=window_days\n+            )\n+            if ticker_data is None:\n+                if error:\n+                    errors.append(f\"{ticker}: {error}\")\n+                logger.warning(\"Prediction failed for %s\", ticker)\n+                continue\n+            results[ticker] = ticker_data\n+\n+        if not results:\n+            return {\n+                'success': False,\n+                'error': 'Unable to generate market predictions',\n+                'details': errors\n+            }\n+\n+        response = {\n+            'success': True,\n+            'tickers': list(results.keys()),\n+            'prediction_days': days,\n+            'window_days': window_days,\n+            'generated_at': datetime.utcnow().isoformat(),\n+            'model_version': 'twelvedata-trend-v1',\n+            'methodology': 'Simple average daily return on recent closes',\n+            'source': 'twelvedata',\n+            'disclaimer': (\n+                'Forecasts are estimates for informational purposes only and are not financial advice.'\n+            ),\n+            'data': results\n+        }\n+        if errors:\n+            response['warnings'] = errors\n+\n+        timeout = current_app.config.get('CACHE_TIMEOUT_MARKET_PREDICTIONS', 300)\n+        CacheService.set(cache_key, response, timeout=timeout)\n+\n+        return response\n+\n+    def _predict_for_ticker(\n+        self,\n+        ticker: str,\n+        start_date: str,\n+        end_date: str,\n+        days: int,\n+        window_days: int\n+    ) -> Tuple[Optional[Dict], Optional[str]]:\n+        client = self._get_twelvedata_client()\n+        data = client.get_time_series(\n+            symbol=ticker,\n+            interval='1day',\n+            outputsize=window_days\n+        )\n+\n+        if not data:\n+            return None, 'No response from Twelve Data API'\n+\n+        if data.get('status') == 'error':\n+            return None, data.get('message', 'Twelve Data error')\n+\n+        if not data.get('values'):\n+            return None, 'No time series values returned'\n+\n+        closes = []\n+        dates = []\n+        for entry in data['values']:\n+            close_price = entry.get('close')\n+            dt_value = entry.get('datetime')\n+            if close_price is None or dt_value is None:\n+                continue\n+            closes.append(float(close_price))\n+            dates.append(dt_value.split(' ')[0])\n+\n+        if len(closes) < 5:\n+            return None, 'Insufficient historical data'\n+\n+        # Values are returned latest first\n+        closes = list(reversed(closes))[-window_days:]\n+        dates = list(reversed(dates))[-window_days:]\n+\n+        avg_return = self._average_daily_return(closes)\n+        avg_return = max(-0.15, min(avg_return, 0.15))\n+\n+        last_close = closes[-1]\n+        last_date = datetime.strptime(dates[-1], '%Y-%m-%d').date()\n+\n+        predictions = []\n+        next_date = self._next_market_day(last_date)\n+        price = last_close\n+\n+        for day_index in range(days):\n+            price = price * (1 + avg_return)\n+            confidence = max(45, 85 - (day_index * 7))\n+            predictions.append({\n+                'date': next_date.strftime('%Y-%m-%d'),\n+                'predicted_price': round(price, 2),\n+                'confidence': confidence,\n+                'daily_return_pct': round(avg_return * 100, 3)\n+            })\n+            next_date = self._next_market_day(next_date)\n+\n+        return {\n+            'latest_close': round(last_close, 2),\n+            'latest_date': last_date.strftime('%Y-%m-%d'),\n+            'predictions': predictions\n+        }, None\n+\n+    @staticmethod\n+    def _average_daily_return(closes: List[float]) -> float:\n+        returns = []\n+        for i in range(1, len(closes)):\n+            prev = closes[i - 1]\n+            if prev <= 0:\n+                continue\n+            returns.append((closes[i] - prev) / prev)\n+        if not returns:\n+            return 0.0\n+        return sum(returns) / len(returns)\n+\n+    @staticmethod\n+    def _next_market_day(date_value):\n+        next_day = date_value + timedelta(days=1)\n+        while next_day.weekday() >= 5:\n+            next_day = next_day + timedelta(days=1)\n+        return next_day\n+\n+    @staticmethod\n+    def _cache_key(tickers: List[str], days: int, window_days: int) -> str:\n+        tickers_key = '-'.join(sorted(tickers))\n+        return f\"market:predictions:{tickers_key}:{days}:{window_days}\"\n+\n+\n+_market_prediction_service = None\n+\n+\n+def get_market_prediction_service() -> MarketPredictionService:\n+    \"\"\"Singleton accessor.\"\"\"\n+    global _market_prediction_service\n+    if _market_prediction_service is None:\n+        _market_prediction_service = MarketPredictionService()\n+    return _market_prediction_service",
      "status": "added"
    },
    {
      "path": "app/static/css/dashboard.css",
      "added": 42,
      "removed": 0,
      "loc": 42,
      "patch": "@@ -223,6 +223,48 @@ body {\n     overflow: hidden;\n }\n \n+/* ETF Forecasts */\n+.etf-grid {\n+    display: grid;\n+    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));\n+    gap: 1.5rem;\n+}\n+\n+.etf-chart-card {\n+    background: #fffdf5;\n+    border: 1px solid var(--border-color);\n+    border-radius: 12px;\n+    padding: 1rem;\n+    box-shadow: var(--shadow);\n+}\n+\n+.etf-header {\n+    display: flex;\n+    align-items: baseline;\n+    gap: 0.75rem;\n+    margin-bottom: 0.75rem;\n+}\n+\n+.etf-badge {\n+    background: var(--secondary-color);\n+    color: #2b1a0a;\n+    font-weight: 700;\n+    font-size: 0.85rem;\n+    padding: 0.2rem 0.5rem;\n+    border-radius: 999px;\n+}\n+\n+.etf-name {\n+    color: var(--text-secondary);\n+    font-size: 0.85rem;\n+}\n+\n+.etf-chart {\n+    min-height: 260px;\n+    border-radius: 8px;\n+    overflow: hidden;\n+}\n+\n /* Astrology Container */\n .astrology-container {\n     display: flex;",
      "status": "modified"
    },
    {
      "path": "app/static/js/etf_forecast.js",
      "added": 158,
      "removed": 0,
      "loc": 158,
      "patch": "@@ -0,0 +1,158 @@\n+/**\n+ * ETF Forecast Charts (Twelve Data)\n+ * Fetches 5-day predictions for SLV and GLD and renders Plotly charts.\n+ */\n+\n+let etfRefreshInterval = null;\n+\n+function initEtfForecasts() {\n+    fetchEtfPredictions();\n+\n+    etfRefreshInterval = setInterval(() => {\n+        fetchEtfPredictions();\n+    }, 300000); // 5 minutes\n+}\n+\n+async function fetchEtfPredictions() {\n+    try {\n+        const response = await fetch('/api/market/predictions?tickers=SLV,GLD&days=5&window=30');\n+        const result = await response.json();\n+\n+        if (result.success && result.data) {\n+            renderEtfChart('SLV', result.data.SLV, 'slvForecastChart', '#7f8c8d');\n+            renderEtfChart('GLD', result.data.GLD, 'gldForecastChart', '#d4af37');\n+            hideError('etfError');\n+        } else {\n+            showError('etfError', result.error || 'Unable to fetch ETF forecasts');\n+        }\n+    } catch (error) {\n+        console.error('Error fetching ETF predictions:', error);\n+        showError('etfError', 'Network error. Unable to load ETF forecasts.');\n+    }\n+}\n+\n+function renderEtfChart(ticker, data, containerId, color) {\n+    const container = document.getElementById(containerId);\n+    if (!container) {\n+        console.error(`ETF chart container ${containerId} not found`);\n+        return;\n+    }\n+\n+    if (!data || !data.predictions) {\n+        container.innerHTML = '<div class=\"chart-placeholder\">No data available</div>';\n+        return;\n+    }\n+\n+    const predictions = data.predictions;\n+    const dates = predictions.map(p => p.date);\n+    const prices = predictions.map(p => p.predicted_price);\n+    const confidences = predictions.map(p => p.confidence || 60);\n+\n+    const upperBound = prices.map((price, i) => {\n+        const confidenceFactor = confidences[i] / 100;\n+        const volatility = 0.015;\n+        return price * (1 + volatility * (1 - confidenceFactor));\n+    });\n+\n+    const lowerBound = prices.map((price, i) => {\n+        const confidenceFactor = confidences[i] / 100;\n+        const volatility = 0.015;\n+        return price * (1 - volatility * (1 - confidenceFactor));\n+    });\n+\n+    const allDates = [data.latest_date, ...dates];\n+    const allPrices = [data.latest_close, ...prices];\n+\n+    const traces = [\n+        {\n+            name: `${ticker} Forecast`,\n+            x: allDates,\n+            y: allPrices,\n+            type: 'scatter',\n+            mode: 'lines+markers',\n+            line: {\n+                color: color,\n+                width: 3,\n+                shape: 'spline'\n+            },\n+            marker: {\n+                size: 7,\n+                color: color,\n+                line: {\n+                    color: '#ffffff',\n+                    width: 1\n+                }\n+            },\n+            hovertemplate: '<b>%{x}</b><br>$%{y:.2f}<extra></extra>'\n+        },\n+        {\n+            name: 'Confidence Band',\n+            x: [...dates, ...dates.slice().reverse()],\n+            y: [...upperBound, ...lowerBound.slice().reverse()],\n+            fill: 'toself',\n+            fillcolor: ticker === 'GLD' ? 'rgba(212, 175, 55, 0.18)' : 'rgba(127, 140, 141, 0.18)',\n+            line: {color: 'transparent'},\n+            showlegend: false,\n+            hoverinfo: 'skip'\n+        }\n+    ];\n+\n+    const layout = {\n+        title: {\n+            text: `${ticker} 5-Day Forecast`,\n+            font: {\n+                size: 14,\n+                color: '#333'\n+            }\n+        },\n+        xaxis: {\n+            showgrid: true,\n+            gridcolor: '#E6E6E6',\n+            tickformat: '%b %d'\n+        },\n+        yaxis: {\n+            showgrid: true,\n+            gridcolor: '#E6E6E6',\n+            tickprefix: '$',\n+            tickformat: ',.2f'\n+        },\n+        plot_bgcolor: '#FAFAFA',\n+        paper_bgcolor: '#FFFFFF',\n+        margin: {\n+            l: 50,\n+            r: 20,\n+            t: 40,\n+            b: 50\n+        },\n+        height: 280,\n+        showlegend: false\n+    };\n+\n+    const config = {\n+        responsive: true,\n+        displayModeBar: false\n+    };\n+\n+    Plotly.newPlot(container, traces, layout, config);\n+}\n+\n+function showError(elementId, message) {\n+    const errorElement = document.getElementById(elementId);\n+    if (errorElement) {\n+        errorElement.textContent = message;\n+        errorElement.style.display = 'block';\n+    }\n+}\n+\n+function hideError(elementId) {\n+    const errorElement = document.getElementById(elementId);\n+    if (errorElement) {\n+        errorElement.style.display = 'none';\n+    }\n+}\n+\n+window.addEventListener('beforeunload', () => {\n+    if (etfRefreshInterval) {\n+        clearInterval(etfRefreshInterval);\n+    }\n+});",
      "status": "added"
    },
    {
      "path": "app/templates/about.html",
      "added": 1,
      "removed": 1,
      "loc": 2,
      "patch": "@@ -30,7 +30,7 @@ <h2 style=\"color: var(--accent-color); font-size: 1.5rem; margin-bottom: 0.5rem;\n         <h2 style=\"color: var(--accent-color); font-size: 1.5rem; margin-bottom: 0.5rem;\">Technology</h2>\n         <p style=\"line-height: 1.8;\">\n             Built with Flask 3.x, Kerykeion for astrological calculations, and Plotly for data visualization.\n-            Data sources include Metals-API for gold prices and Swiss Ephemeris for planetary positions.\n+            Data sources include Twelve Data for gold prices and Swiss Ephemeris for planetary positions.\n         </p>\n     </section>\n ",
      "status": "modified"
    },
    {
      "path": "app/templates/dashboard.html",
      "added": 28,
      "removed": 0,
      "loc": 28,
      "patch": "@@ -30,6 +30,28 @@ <h3 class=\"chart-title\">30-Day Price Trajectory</h3>\n             <div id=\"goldChart\" class=\"gold-chart\"></div>\n             <div id=\"chartError\" class=\"error-message\" style=\"display: none;\"></div>\n         </div>\n+\n+        <!-- ETF Forecasts -->\n+        <div class=\"chart-container\">\n+            <h3 class=\"chart-title\">5-Day ETF Forecast (Twelve Data)</h3>\n+            <div class=\"etf-grid\">\n+                <div class=\"etf-chart-card\">\n+                    <div class=\"etf-header\">\n+                        <span class=\"etf-badge\">SLV</span>\n+                        <span class=\"etf-name\">iShares Silver Trust</span>\n+                    </div>\n+                    <div id=\"slvForecastChart\" class=\"etf-chart\"></div>\n+                </div>\n+                <div class=\"etf-chart-card\">\n+                    <div class=\"etf-header\">\n+                        <span class=\"etf-badge\">GLD</span>\n+                        <span class=\"etf-name\">SPDR Gold Shares</span>\n+                    </div>\n+                    <div id=\"gldForecastChart\" class=\"etf-chart\"></div>\n+                </div>\n+            </div>\n+            <div id=\"etfError\" class=\"error-message\" style=\"display: none;\"></div>\n+        </div>\n     </section>\n \n     <!-- Right Column: Vedic Price Predictions -->\n@@ -81,6 +103,7 @@ <h2>Planetary Positions</h2>\n \n {% block extra_js %}\n <script src=\"{{ url_for('static', filename='js/gold_chart.js') }}\"></script>\n+<script src=\"{{ url_for('static', filename='js/etf_forecast.js') }}\"></script>\n <script src=\"{{ url_for('static', filename='js/astrology_display.js') }}\"></script>\n <script src=\"{{ url_for('static', filename='js/prediction_chart.js') }}\"></script>\n <script>\n@@ -104,6 +127,11 @@ <h2>Planetary Positions</h2>\n             window.silverPredictionChart = new VedicPredictionChart('silver', 'silver-prediction-chart', 14);\n             window.silverPredictionChart.init();\n         }\n+\n+        // Initialize ETF forecast charts\n+        if (typeof initEtfForecasts === 'function') {\n+            initEtfForecasts();\n+        }\n     });\n </script>\n {% endblock %}",
      "status": "modified"
    }
  ],
  "diff_summary": "Fetched diff from https://github.com/divyabairavarasu/gold-spiritual-dasboard/pull/2",
  "test_summary": "",
  "ci_summary": ""
}